/**
 * EditManager.js - Gestion de l'√©dition des horaires
 * Contr√¥le la logique m√©tier de l'√©dition des plannings
 * CORRECTION : Utilisation d'IDs nettoy√©s pour √©viter les erreurs querySelector
 */

class EditManager {
    constructor(dataManager, displayManager) {
        this.dataManager = dataManager;
        this.displayManager = displayManager;
        this.editingStates = new Map(); // dateString -> originalData
        this.editRenderer = new EditRenderer();
        
        console.log('‚úèÔ∏è EditManager initialis√©');
    }

    /**
     * Nettoie un string pour en faire un ID CSS valide
     * (M√™me m√©thode que EditRenderer pour coh√©rence)
     */
    sanitizeId(str) {
        return str
            .replace(/\s+/g, '-')        // Remplace espaces par tirets
            .replace(/[^a-zA-Z0-9-_]/g, '') // Supprime caract√®res sp√©ciaux
            .toLowerCase();               // En minuscules
    }

    /**
     * Active le mode √©dition pour un jour
     * @param {string} dateString - Date au format string (ex: "Mon Jun 24 2025")
     * @returns {boolean} True si l'√©dition a √©t√© activ√©e avec succ√®s
     */
    startEdit(dateString) {
        try {
            console.log('‚úèÔ∏è D√©but √©dition pour:', dateString);
            
            // V√©rifier si le jour existe dans les donn√©es
            const dayData = this.findDayData(dateString);
            if (!dayData) {
                console.error('‚ùå Aucune donn√©e trouv√©e pour:', dateString);
                this.displayManager.showMessage('Aucune donn√©e trouv√©e pour cette date', 'error');
                return false;
            }

            // V√©rifier si d√©j√† en cours d'√©dition
            if (this.editingStates.has(dateString)) {
                console.log('‚ö†Ô∏è √âdition d√©j√† en cours pour:', dateString);
                return false;
            }

            // Sauvegarder l'√©tat original
            this.editingStates.set(dateString, JSON.parse(JSON.stringify(dayData)));

            // Trouver le conteneur du jour
            const dayContainer = this.findDayContainer(dateString);
            if (!dayContainer) {
                console.error('‚ùå Conteneur du jour non trouv√© pour:', dateString);
                this.displayManager.showMessage('Conteneur du jour non trouv√©', 'error');
                return false;
            }

            // Masquer l'affichage normal
            const normalDisplay = dayContainer.querySelector('.day-content');
            if (normalDisplay) {
                normalDisplay.style.display = 'none';
            }

            // Afficher l'interface d'√©dition
            this.editRenderer.renderEditInterface(dayData, dayContainer);

            // Focus sur le premier champ
            const sanitizedDateStr = this.sanitizeId(dateString);
            setTimeout(() => {
                this.editRenderer.focusFirstField(sanitizedDateStr);
            }, 100);

            console.log('‚úÖ Mode √©dition activ√© pour:', dateString);
            return true;

        } catch (error) {
            console.error('‚ùå Erreur lors du d√©marrage de l\'√©dition:', error);
            this.displayManager.showMessage('Erreur lors de l\'activation du mode √©dition', 'error');
            return false;
        }
    }

    /**
     * Sauvegarde les modifications d'un jour
     * @param {string} dateString - Date au format string
     * @returns {boolean} True si la sauvegarde a r√©ussi
     */
    saveDay(dateString) {
        try {
            console.log('üíæ Sauvegarde en cours pour:', dateString);
            
            if (!this.editingStates.has(dateString)) {
                console.error('‚ùå Aucune √©dition en cours pour:', dateString);
                this.displayManager.showMessage('Aucune √©dition en cours', 'error');
                return false;
            }

            // Cr√©er l'ID nettoy√© pour retrouver l'interface
            const sanitizedDateStr = this.sanitizeId(dateString);
            
            // Collecter les donn√©es depuis l'interface
            const editData = this.editRenderer.collectEditData(sanitizedDateStr);
            if (!editData) {
                console.error('‚ùå Impossible de collecter les donn√©es d\'√©dition');
                this.editRenderer.showEditError(sanitizedDateStr, 'Erreur lors de la collecte des donn√©es');
                return false;
            }

            // Valider les donn√©es
            const validation = this.validateEditData(editData);
            if (!validation.isValid) {
                console.error('‚ùå Donn√©es invalides:', validation.errors);
                this.editRenderer.showEditError(sanitizedDateStr, validation.errors.join(', '));
                return false;
            }

            // Mettre √† jour les donn√©es
            const success = this.updateDayData(dateString, editData);
            if (!success) {
                console.error('‚ùå √âchec de la mise √† jour des donn√©es');
                this.editRenderer.showEditError(sanitizedDateStr, 'Erreur lors de la mise √† jour');
                return false;
            }

            // Quitter le mode √©dition
            this.finishEdit(dateString);

            // Sauvegarder dans le localStorage
            this.dataManager.saveToLocalStorage();

            // Rafra√Æchir l'affichage
            this.displayManager.displayCurrentWeek();

            // Afficher un message de succ√®s
            this.displayManager.showMessage('Modifications sauvegard√©es avec succ√®s', 'success');

            console.log('‚úÖ Sauvegarde termin√©e pour:', dateString);
            return true;

        } catch (error) {
            console.error('‚ùå Erreur lors de la sauvegarde:', error);
            this.displayManager.showMessage('Erreur lors de la sauvegarde', 'error');
            return false;
        }
    }

    /**
     * Annule l'√©dition d'un jour
     * @param {string} dateString - Date au format string
     * @returns {boolean} True si l'annulation a r√©ussi
     */
    cancelEdit(dateString) {
        try {
            console.log('‚ùå Annulation √©dition pour:', dateString);
            
            if (!this.editingStates.has(dateString)) {
                console.error('‚ùå Aucune √©dition en cours pour:', dateString);
                return false;
            }

            // Quitter le mode √©dition sans sauvegarder
            this.finishEdit(dateString);

            // Rafra√Æchir l'affichage pour restaurer l'√©tat original
            this.displayManager.displayCurrentWeek();

            this.displayManager.showMessage('Modifications annul√©es', 'info');

            console.log('‚úÖ √âdition annul√©e pour:', dateString);
            return true;

        } catch (error) {
            console.error('‚ùå Erreur lors de l\'annulation:', error);
            this.displayManager.showMessage('Erreur lors de l\'annulation', 'error');
            return false;
        }
    }

    /**
     * Termine le mode √©dition (nettoie l'√©tat)
     * @param {string} dateString - Date au format string
     */
    finishEdit(dateString) {
        // Supprimer l'√©tat d'√©dition
        this.editingStates.delete(dateString);

        // Supprimer l'interface d'√©dition
        const sanitizedDateStr = this.sanitizeId(dateString);
        this.editRenderer.removeEditInterface(sanitizedDateStr);

        console.log('üîö Mode √©dition termin√© pour:', dateString);
    }

    /**
     * Trouve les donn√©es d'un jour
     * @param {string} dateString - Date au format string
     * @returns {Object|null} Donn√©es du jour ou null
     */
    findDayData(dateString) {
        try {
            const targetDate = new Date(dateString);
            const allData = this.dataManager.getAllData();
            
            return allData.find(item => {
                const itemDate = new Date(item.date);
                return itemDate.getTime() === targetDate.getTime();
            });
        } catch (error) {
            console.error('‚ùå Erreur lors de la recherche des donn√©es du jour:', error);
            return null;
        }
    }

    /**
     * Trouve le conteneur DOM d'un jour
     * @param {string} dateString - Date au format string
     * @returns {HTMLElement|null} Conteneur du jour ou null
     */
    findDayContainer(dateString) {
        try {
            const targetDate = new Date(dateString);
            const dayContainers = document.querySelectorAll('.day');
            
            for (let container of dayContainers) {
                const dayData = container.dayData;
                if (dayData && dayData.date.getTime() === targetDate.getTime()) {
                    return container;
                }
            }
            
            return null;
        } catch (error) {
            console.error('‚ùå Erreur lors de la recherche du conteneur:', error);
            return null;
        }
    }

    /**
     * Valide les donn√©es d'√©dition
     * @param {Object} editData - Donn√©es √† valider
     * @returns {Object} R√©sultat de validation {isValid, errors}
     */
    validateEditData(editData) {
        const errors = [];

        try {
            // Validation des horaires si ce n'est pas un jour de repos
            if (!editData.isRestDay && editData.schedules.length > 0) {
                for (let schedule of editData.schedules) {
                    if (schedule && schedule.includes('-')) {
                        const [start, end] = schedule.split('-');
                        
                        // V√©rifier le format
                        const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
                        if (!timeRegex.test(start)) {
                            errors.push(`Heure de d√©but invalide: ${start}`);
                        }
                        if (!timeRegex.test(end)) {
                            errors.push(`Heure de fin invalide: ${end}`);
                        }
                        
                        // V√©rifier la coh√©rence
                        if (timeRegex.test(start) && timeRegex.test(end)) {
                            const startTime = new Date(`2000-01-01T${start}:00`);
                            const endTime = new Date(`2000-01-01T${end}:00`);
                            
                            // G√©rer les horaires de nuit (ex: 22:00-06:00)
                            if (startTime > endTime) {
                                // V√©rifier si c'est un horaire de nuit valide
                                const startHour = parseInt(start.split(':')[0]);
                                const endHour = parseInt(end.split(':')[0]);
                                
                                if (!(startHour >= 18 && endHour <= 12)) {
                                    errors.push(`Horaire invalide: ${schedule} (si c'est un horaire de nuit, l'heure de d√©but doit √™tre >= 18h et l'heure de fin <= 12h)`);
                                }
                            }
                        }
                    }
                }
            }

            // Validation du lieu (optionnelle mais avec limite de caract√®res)
            if (editData.location && editData.location.length > 100) {
                errors.push('Le lieu ne peut pas d√©passer 100 caract√®res');
            }

            // Validation des t√¢ches (optionnelle mais avec limite de caract√®res)
            if (editData.tasks && editData.tasks.length > 500) {
                errors.push('La description des t√¢ches ne peut pas d√©passer 500 caract√®res');
            }

            // Validation sp√©cifique : pas d'horaires si jour de repos
            if (editData.isRestDay && editData.schedules.length > 0) {
                errors.push('Un jour de repos ne peut pas avoir d\'horaires');
            }

            // Validation sp√©cifique : au moins un horaire si pas jour de repos
            if (!editData.isRestDay && editData.schedules.length === 0) {
                errors.push('Un jour de travail doit avoir au moins un horaire');
            }

        } catch (error) {
            console.error('‚ùå Erreur lors de la validation:', error);
            errors.push('Erreur lors de la validation des donn√©es');
        }

        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }

    /**
     * Met √† jour les donn√©es d'un jour
     * @param {string} dateString - Date au format string
     * @param {Object} editData - Nouvelles donn√©es
     * @returns {boolean} True si la mise √† jour a r√©ussi
     */
    updateDayData(dateString, editData) {
        try {
            const dayData = this.findDayData(dateString);
            if (!dayData) {
                console.error('‚ùå Donn√©es du jour non trouv√©es pour mise √† jour');
                return false;
            }

            // Mettre √† jour les propri√©t√©s
            dayData.isRestDay = editData.isRestDay;
            dayData.location = editData.location;
            dayData.tasks = editData.tasks;

            // Mettre √† jour les horaires
            if (editData.isRestDay) {
                dayData.schedules = [];
                dayData.originalHoraire = 'Repos';
            } else {
                dayData.schedules = editData.schedules.filter(s => s && s.trim());
                dayData.originalHoraire = dayData.schedules.join(' | ');
            }

            // Recalculer les propri√©t√©s d√©riv√©es
            this.recalculateDayProperties(dayData);

            console.log('‚úÖ Donn√©es mises √† jour:', dayData);
            return true;

        } catch (error) {
            console.error('‚ùå Erreur lors de la mise √† jour des donn√©es:', error);
            return false;
        }
    }

    /**
     * Recalcule les propri√©t√©s d√©riv√©es d'un jour
     * @param {Object} dayData - Donn√©es du jour √† recalculer
     */
    recalculateDayProperties(dayData) {
        try {
            if (dayData.isRestDay || !dayData.schedules || dayData.schedules.length === 0) {
                dayData.totalHours = 0;
                dayData.hasMultipleSlots = false;
                dayData.isNightShift = false;
            } else {
                // Recalculer avec TimeUtils
                const timeUtils = window.TimeUtils;
                if (timeUtils) {
                    dayData.totalHours = timeUtils.calculateTotalHours(dayData.schedules);
                    dayData.hasMultipleSlots = dayData.schedules.length > 1;
                    dayData.isNightShift = dayData.schedules.some(schedule => 
                        timeUtils.isNightShift(schedule)
                    );
                } else {
                    console.error('‚ùå TimeUtils non disponible');
                    dayData.totalHours = 0;
                    dayData.hasMultipleSlots = dayData.schedules.length > 1;
                    dayData.isNightShift = false;
                }
            }
        } catch (error) {
            console.error('‚ùå Erreur lors du recalcul des propri√©t√©s:', error);
        }
    }

    /**
     * V√©rifie si un jour est en cours d'√©dition
     * @param {string} dateString - Date au format string
     * @returns {boolean} True si en cours d'√©dition
     */
    isEditing(dateString) {
        return this.editingStates.has(dateString);
    }

    /**
     * Annule toutes les √©ditions en cours
     * @returns {number} Nombre d'√©ditions annul√©es
     */
    cancelAllEdits() {
        const editingDates = Array.from(this.editingStates.keys());
        let cancelledCount = 0;
        
        for (let dateString of editingDates) {
            if (this.cancelEdit(dateString)) {
                cancelledCount++;
            }
        }
        
        console.log(`‚ùå ${cancelledCount} √©ditions annul√©es`);
        return cancelledCount;
    }

    /**
     * Obtient le nombre d'√©ditions en cours
     * @returns {number} Nombre d'√©ditions actives
     */
    getEditingCount() {
        return this.editingStates.size;
    }

    /**
     * Obtient la liste des dates en cours d'√©dition
     * @returns {Array} Liste des dates en cours d'√©dition
     */
    getEditingDates() {
        return Array.from(this.editingStates.keys());
    }

    /**
     * Sauvegarde rapide de toutes les √©ditions en cours
     * @returns {Object} R√©sultat {success: number, failed: number}
     */
    saveAllEdits() {
        const editingDates = Array.from(this.editingStates.keys());
        let successCount = 0;
        let failedCount = 0;
        
        for (let dateString of editingDates) {
            if (this.saveDay(dateString)) {
                successCount++;
            } else {
                failedCount++;
            }
        }
        
        console.log(`üíæ Sauvegarde multiple: ${successCount} r√©ussies, ${failedCount} √©chou√©es`);
        
        return {
            success: successCount,
            failed: failedCount
        };
    }

    /**
     * Duplique les horaires d'un jour vers un autre
     * @param {string} sourceDateString - Date source
     * @param {string} targetDateString - Date cible
     * @returns {boolean} True si la duplication a r√©ussi
     */
    duplicateDay(sourceDateString, targetDateString) {
        try {
            const sourceData = this.findDayData(sourceDateString);
            const targetData = this.findDayData(targetDateString);
            
            if (!sourceData || !targetData) {
                console.error('‚ùå Donn√©es source ou cible non trouv√©es');
                return false;
            }

            // Copier les propri√©t√©s
            targetData.isRestDay = sourceData.isRestDay;
            targetData.location = sourceData.location;
            targetData.tasks = sourceData.tasks;
            targetData.schedules = [...sourceData.schedules];
            targetData.originalHoraire = sourceData.originalHoraire;

            // Recalculer les propri√©t√©s d√©riv√©es
            this.recalculateDayProperties(targetData);

            // Sauvegarder
            this.dataManager.saveToLocalStorage();

            // Rafra√Æchir l'affichage
            this.displayManager.displayCurrentWeek();

            console.log(`‚úÖ Jour dupliqu√© de ${sourceDateString} vers ${targetDateString}`);
            return true;

        } catch (error) {
            console.error('‚ùå Erreur lors de la duplication:', error);
            return false;
        }
    }

    /**
     * R√©initialise un jour (remet √† z√©ro)
     * @param {string} dateString - Date au format string
     * @returns {boolean} True si la r√©initialisation a r√©ussi
     */
    resetDay(dateString) {
        try {
            const dayData = this.findDayData(dateString);
            if (!dayData) {
                console.error('‚ùå Donn√©es du jour non trouv√©es');
                return false;
            }

            // R√©initialiser les propri√©t√©s
            dayData.isRestDay = false;
            dayData.location = '';
            dayData.tasks = '';
            dayData.schedules = [];
            dayData.originalHoraire = '';
            dayData.totalHours = 0;
            dayData.hasMultipleSlots = false;
            dayData.isNightShift = false;

            // Sauvegarder
            this.dataManager.saveToLocalStorage();

            // Rafra√Æchir l'affichage
            this.displayManager.displayCurrentWeek();

            console.log(`‚úÖ Jour r√©initialis√©: ${dateString}`);
            return true;

        } catch (error) {
            console.error('‚ùå Erreur lors de la r√©initialisation:', error);
            return false;
        }
    }

    /**
     * Obtient les statistiques d'√©dition
     * @returns {Object} Statistiques
     */
    getEditingStats() {
        return {
            currentlyEditing: this.editingStates.size,
            editingDates: Array.from(this.editingStates.keys()),
            hasUnsavedChanges: this.editingStates.size > 0
        };
    }

    /**
     * V√©rifie s'il y a des modifications non sauvegard√©es
     * @returns {boolean} True s'il y a des modifications en attente
     */
    hasUnsavedChanges() {
        return this.editingStates.size > 0;
    }

    /**
     * Nettoie les √©tats d'√©dition orphelins
     * Supprime les √©tats d'√©dition qui n'ont plus d'interface correspondante
     */
    cleanupOrphanedStates() {
        const editingDates = Array.from(this.editingStates.keys());
        let cleanedCount = 0;
        
        for (let dateString of editingDates) {
            const sanitizedDateStr = this.sanitizeId(dateString);
            if (!this.editRenderer.hasEditInterface(sanitizedDateStr)) {
                this.editingStates.delete(dateString);
                cleanedCount++;
                console.log('üßπ √âtat d\'√©dition orphelin supprim√©:', dateString);
            }
        }
        
        if (cleanedCount > 0) {
            console.log(`üßπ ${cleanedCount} √©tats orphelins nettoy√©s`);
        }
        
        return cleanedCount;
    }
}

// Export pour usage global
window.EditManager = EditManager;